// frontend/src/services/mls/coreCryptoClient.js
// Thin bootstrap wrapper around @wireapp/core-crypto guarded by an MLS feature flag.

import {
  CoreCrypto,
  DatabaseKey,
  ClientId,
  ConversationId,
  CredentialType,
  MlsTransportData,
  ciphersuiteDefault,
  initWasmModule,
  openDatabase
} from '@wireapp/core-crypto';
import coreCryptoWasmUrl from '@wireapp/core-crypto/src/autogenerated/core-crypto-ffi_bg.wasm?url';
import { api, ApiError } from '../api.js';
import { getTokenData } from '../auth.js';
import messagingStore from '../../stores/messagingStore.js';

const featureFlagRaw = import.meta.env.VITE_ENABLE_MLS;
const FEATURE_FLAG = featureFlagRaw == null
  ? true
  : String(featureFlagRaw).toLowerCase() === 'true';
const WASM_BASE = import.meta.env.VITE_CORE_CRYPTO_WASM_BASE;
const DATABASE_NAME = 'intellacc-mls-keystore';
const KEY_STORAGE_KEY = 'intellacc.mls.databaseKey';
const CLIENT_ID_STORAGE_KEY = 'intellacc.mls.clientId';
const KEYPACKAGE_UPLOAD_TS_KEY = 'intellacc.mls.keypackages.lastUploadTs';

let DEFAULT_CIPHERSUITE = 1;
let defaultCiphersuiteResolved = false;
const DEFAULT_KEYPACKAGE_TARGET = Number(import.meta.env.VITE_MLS_KEYPACKAGE_TARGET ?? 5);
const KEYPACKAGE_UPLOAD_MIN_INTERVAL_MS = Number(import.meta.env.VITE_MLS_KEYPACKAGE_UPLOAD_INTERVAL_MS ?? (6 * 60 * 60 * 1000)); // default 6h
const CREDENTIAL_STORAGE_KEY = 'intellacc.mls.credential';
const CREDENTIAL_REFRESH_GRACE_MS = Number(import.meta.env.VITE_MLS_CREDENTIAL_REFRESH_GRACE_MS ?? (5 * 60 * 1000));

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

const transportContext = {
  conversationId: null
};

const pushTransportDiagnostic = (entry = {}) => {
  try {
    messagingStore.pushDiagnosticEvent({
      category: 'transport',
      ...entry
    });
  } catch (err) {
    if (import.meta?.env?.DEV) console.warn('[MLS] Failed to record transport diagnostic', err);
  }
};

const installCoreCryptoLogger = (instance) => {
  if (!import.meta?.env?.DEV) return;
  const setLoggerFn = typeof CoreCrypto?.setLogger === 'function'
    ? CoreCrypto.setLogger.bind(CoreCrypto)
    : (typeof instance?.setLogger === 'function' ? instance.setLogger.bind(instance) : null);
  if (!setLoggerFn) return;

  const logger = (level, target, message) => {
    const normalizedLevel = typeof level === 'string' ? level.toLowerCase() : String(level || 'info').toLowerCase();
    const text = typeof message === 'string' ? message : (() => {
      try { return JSON.stringify(message); } catch { return String(message); }
    })();
    const targetLabel = target || 'core';
    const entry = {
      category: 'core-crypto',
      level: normalizedLevel,
      message: `[${targetLabel}] ${text}`,
      data: { level, target }
    };
    try {
      messagingStore.pushDiagnosticEvent(entry);
    } catch {}

    const prefix = `[MLS ${targetLabel}]`;
    if (normalizedLevel === 'error') {
      console.error(prefix, text);
    } else if (normalizedLevel === 'warn' || normalizedLevel === 'warning') {
      console.warn(prefix, text);
    } else {
      console.debug(prefix, text);
    }
  };

  try {
    setLoggerFn(logger);
  } catch (err) {
    console.warn('[MLS] Failed to install CoreCrypto logger', err);
  }

  const setLevelFn = typeof CoreCrypto?.setMaxLogLevel === 'function'
    ? CoreCrypto.setMaxLogLevel.bind(CoreCrypto)
    : (typeof instance?.setMaxLogLevel === 'function' ? instance.setMaxLogLevel.bind(instance) : null);
  if (setLevelFn) {
    const desired = CoreCrypto?.LogLevel?.Debug ?? instance?.LogLevel?.Debug ?? 'debug';
    try {
      setLevelFn(desired);
    } catch (err) {
      console.warn('[MLS] Failed to set CoreCrypto log level', err);
    }
  }
};

let coreCryptoInstance = null;
let initPromise = null;
let bootstrapPromise = null;
let cachedCredentialInfo = null;

const getCrypto = () => (typeof window !== 'undefined' ? window.crypto : null);
const getStorage = () => (typeof window !== 'undefined' ? window.localStorage : null);

const base64ToBytes = (value) => {
  if (!value) return null;
  try {
    const raw = atob(value);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i += 1) bytes[i] = raw.charCodeAt(i);
    return bytes;
  } catch {
    return null;
  }
};

const bytesToBase64 = (bytes) => {
  if (!bytes) return '';
  let binary = '';
  for (let i = 0; i < bytes.length; i += 1) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
};

const randomBytes = (length) => {
  const crypto = getCrypto();
  const buffer = new Uint8Array(length);
  if (crypto?.getRandomValues) {
    crypto.getRandomValues(buffer);
    return buffer;
  }
  for (let i = 0; i < buffer.length; i += 1) buffer[i] = Math.floor(Math.random() * 256);
  return buffer;
};

const getOrCreateDatabaseKey = () => {
  const storage = getStorage();
  if (!storage) return randomBytes(32);
  const cached = base64ToBytes(storage.getItem(KEY_STORAGE_KEY));
  if (cached?.length === 32) return cached;
  const fresh = randomBytes(32);
  storage.setItem(KEY_STORAGE_KEY, bytesToBase64(fresh));
  return fresh;
};

const getOrCreateClientId = () => {
  const storage = getStorage();
  if (!storage) return randomBytes(16);
  const cached = base64ToBytes(storage.getItem(CLIENT_ID_STORAGE_KEY));
  if (cached?.length === 16) return cached;
  const fresh = randomBytes(16);
  storage.setItem(CLIENT_ID_STORAGE_KEY, bytesToBase64(fresh));
  return fresh;
};

const createTransport = () => ({
  async sendCommitBundle(commitBundle) {
    const conversationId = transportContext.conversationId;
    if (conversationId == null) {
      if (import.meta?.env?.DEV) {
        console.warn('[MLS] sendCommitBundle invoked without active conversation context');
      }
      pushTransportDiagnostic({
        level: 'error',
        message: 'sendCommitBundle invoked without conversation context'
      });
      return { abort: { reason: 'missing_conversation' } };
    }

    const payload = {
      conversationId,
      senderClientId: getClientIdBase64(),
      bundle: commitBundle?.commit ? bytesToBase64(commitBundle.commit) : null,
      welcome: commitBundle?.welcome ? bytesToBase64(commitBundle.welcome) : null,
      groupInfo: commitBundle?.groupInfo?.payload ? bytesToBase64(commitBundle.groupInfo.payload) : null,
      encryptedMessage: commitBundle?.encryptedMessage ? bytesToBase64(commitBundle.encryptedMessage) : null
    };

    try {
      await api.mls.sendCommitBundle(payload);
      return 'success';
    } catch (error) {
      console.warn('[MLS] Failed to send commit bundle', error);
      pushTransportDiagnostic({
        conversationId,
        level: 'error',
        message: 'Failed to send commit bundle',
        error: error?.message || String(error)
      });
      return { abort: { reason: error?.message || 'commit_failed' } };
    }
  },
  async sendMessage(message) {
    // CoreCrypto may request direct fan-out for application messages; the messaging service already handles this path.
    // Acknowledge success to avoid duplicate delivery attempts.
    return 'success';
  },
  async prepareForTransport(secret) {
    try {
      if (secret?.data?.length) {
        const senderClientId = secret.clientId?.copyBytes?.()
          ? bytesToBase64(secret.clientId.copyBytes())
          : null;
        const epochValue = typeof secret?.epoch === 'number'
          ? secret.epoch
          : (typeof secret?.epoch?.valueOf === 'function' ? Number(secret.epoch.valueOf()) : null);
        await api.mls.sendHistorySecret({
          conversationId: transportContext.conversationId ?? null,
          senderClientId,
          epoch: Number.isInteger(epochValue) ? epochValue : null,
          data: bytesToBase64(secret.data)
        });
      }
    } catch (error) {
      if (import.meta?.env?.DEV) {
        console.warn('[MLS] Failed to send history secret', error);
      }
      pushTransportDiagnostic({
        conversationId: transportContext.conversationId ?? null,
        level: 'warn',
        message: 'Failed to send history secret',
        error: error?.message || String(error)
      });
    }
    return new MlsTransportData(secret?.data ?? new Uint8Array());
  }
});

const bootstrapCoreCrypto = async () => {
  let wasmOverride;
  if (typeof WASM_BASE === 'string') {
    const trimmed = WASM_BASE.trim();
    if (trimmed.length > 0) {
      wasmOverride = trimmed.endsWith('.wasm')
        ? trimmed
        : `${trimmed.replace(/\/+$/, '')}/core-crypto-ffi_bg.wasm`;
    }
  }

  const resolvedWasmUrl = wasmOverride || coreCryptoWasmUrl;

  try {
    await initWasmModule(resolvedWasmUrl);
  } catch (err) {
    if (import.meta?.env?.DEV) {
      console.warn('[MLS] Failed to init WASM via resolved URL, falling back to default init', err);
    }
    await initWasmModule();
  }

  if (!defaultCiphersuiteResolved) {
    try {
      DEFAULT_CIPHERSUITE = ciphersuiteDefault();
      DEFAULT_MLS_CIPHERSUITE = DEFAULT_CIPHERSUITE;
      defaultCiphersuiteResolved = true;
    } catch (err) {
      if (import.meta?.env?.DEV) {
        console.warn('[MLS] Failed to resolve default ciphersuite from core-crypto, using fallback 1', err);
      }
    }
  }

  const keyMaterial = getOrCreateDatabaseKey();

  // Ensure the encrypted keystore exists before initializing CoreCrypto. `openDatabase`
  // consumes the provided DatabaseKey instance, so instantiate it with a copy of the bytes.
  await openDatabase(DATABASE_NAME, new DatabaseKey(keyMaterial.slice()));

  const databaseKey = new DatabaseKey(keyMaterial.slice());
  const clientId = new ClientId(getOrCreateClientId());
  const params = {
    databaseName: DATABASE_NAME,
    key: databaseKey,
    clientId,
    ciphersuites: [DEFAULT_CIPHERSUITE]
  };

  const instance = await CoreCrypto.init(params);
  installCoreCryptoLogger(instance);
  await instance.provideTransport(createTransport());
  return instance;
};

export const isMlsEnabled = () => FEATURE_FLAG;

export const getCoreCrypto = async () => {
  if (!FEATURE_FLAG) return null;
  if (coreCryptoInstance) return coreCryptoInstance;
  if (!initPromise) {
    initPromise = bootstrapCoreCrypto()
      .then((instance) => {
        coreCryptoInstance = instance;
        return instance;
      })
      .catch((error) => {
        initPromise = null;
        throw error;
      });
  }
  return initPromise;
};

export const resetCoreCrypto = async () => {
  if (coreCryptoInstance) {
    try {
      await coreCryptoInstance.close?.();
    } catch {}
  }
  coreCryptoInstance = null;
  initPromise = null;
};

const shouldSkipKeyPackageUpload = () => {
  const storage = getStorage();
  if (!storage) return false;
  const last = Number(storage.getItem(KEYPACKAGE_UPLOAD_TS_KEY) || 0);
  if (!last) return false;
  return (Date.now() - last) < KEYPACKAGE_UPLOAD_MIN_INTERVAL_MS;
};

const markKeyPackagesUploaded = () => {
  const storage = getStorage();
  if (!storage) return;
  storage.setItem(KEYPACKAGE_UPLOAD_TS_KEY, String(Date.now()));
};

const readStoredCredential = () => {
  const storage = getStorage();
  if (!storage) return null;
  try {
    const raw = storage.getItem(CREDENTIAL_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    cachedCredentialInfo = parsed;
    return parsed;
  } catch {
    storage.removeItem?.(CREDENTIAL_STORAGE_KEY);
    cachedCredentialInfo = null;
    return null;
  }
};

const writeStoredCredential = (value) => {
  const storage = getStorage();
  if (!storage) return;
  if (!value) {
    storage.removeItem(CREDENTIAL_STORAGE_KEY);
    cachedCredentialInfo = null;
    return;
  }
  try {
    storage.setItem(CREDENTIAL_STORAGE_KEY, JSON.stringify(value));
    cachedCredentialInfo = value;
  } catch {
    storage.removeItem(CREDENTIAL_STORAGE_KEY);
    cachedCredentialInfo = null;
  }
};

const shouldRefreshCredential = (entry) => {
  if (!entry || typeof entry !== 'object') return true;
  const expiresAt = entry.expiresAt ? Date.parse(entry.expiresAt) : NaN;
  if (!Number.isFinite(expiresAt)) return true;
  return (expiresAt - Date.now()) <= CREDENTIAL_REFRESH_GRACE_MS;
};

const parseCredentialResponse = (credentialB64) => {
  if (!credentialB64) return null;
  try {
    const bytes = base64ToBytes(credentialB64);
    if (!bytes) return null;
    return JSON.parse(textDecoder.decode(bytes));
  } catch {
    return null;
  }
};

const isIgnorableMlsInitError = (error) => {
  const message = typeof error?.message === 'string' ? error.message : '';
  if (!message) return false;
  return /already\s+(?:initialized|exists)/i.test(message);
};

export const runWithConversationContext = async (conversationId, fn) => {
  const previous = transportContext.conversationId;
  transportContext.conversationId = Number.isInteger(Number(conversationId)) ? Number(conversationId) : null;
  try {
    return await fn();
  } finally {
    transportContext.conversationId = previous;
  }
};

export const ensureConversationCreated = async (conversationId) => {
  if (!FEATURE_FLAG) return false;
  const coreCrypto = await getCoreCrypto();
  if (!coreCrypto) return false;
  const convId = createConversationId(conversationId);
  return coreCrypto.transaction(async (ctx) => {
    const exists = await ctx.conversationExists(convId);
    if (exists) return false;
    await ctx.createConversation(convId, CredentialType.Basic);
    return true;
  });
};

export const addClientsToConversation = async (conversationId, keyPackages) => {
  if (!FEATURE_FLAG) return false;
  if (!Array.isArray(keyPackages) || keyPackages.length === 0) return false;
  const coreCrypto = await getCoreCrypto();
  if (!coreCrypto) return false;
  const convId = createConversationId(conversationId);
  return runWithConversationContext(conversationId, async () => coreCrypto.transaction(async (ctx) => {
    await ctx.addClientsToConversation(convId, keyPackages);
    return true;
  }));
};

export const commitPendingProposals = async (conversationId) => {
  if (!FEATURE_FLAG) return false;
  const coreCrypto = await getCoreCrypto();
  if (!coreCrypto) return false;
  const convId = createConversationId(conversationId);
  return runWithConversationContext(conversationId, async () => coreCrypto.transaction(async (ctx) => {
    await ctx.commitPendingProposals(convId);
    return true;
  }).catch((err) => {
    if (import.meta?.env?.DEV) {
      console.warn('[MLS] commitPendingProposals failed', err);
    }
    return false;
  }));
};

const ensureCredentialProvisioned = async (coreCrypto, { userId, clientIdBytes, clientIdBase64 }) => {
  const cached = readStoredCredential();
  if (!shouldRefreshCredential(cached)) return cached;

  if (!Number.isInteger(Number(userId))) {
    throw new Error('MLS credential provisioning requires a numeric user id');
  }

  let publicKeyBytes = null;
  await coreCrypto.transaction(async (ctx) => {
    const clientId = new ClientId(clientIdBytes.slice());
    try {
      await ctx.mlsInit(clientId, [DEFAULT_CIPHERSUITE]);
    } catch (err) {
      if (!isIgnorableMlsInitError(err)) {
        throw err;
      }
    }
    publicKeyBytes = await ctx.clientPublicKey(DEFAULT_CIPHERSUITE, CredentialType.Basic);
  });

  if (!publicKeyBytes) {
    throw new Error('Failed to retrieve MLS public key for credential provisioning');
  }

  const nowIso = new Date().toISOString();
  const requestPayload = {
    version: 1,
    subject: { userId, clientId: clientIdBase64 },
    ciphersuite: DEFAULT_CIPHERSUITE,
    credentialType: 'basic',
    publicKey: bytesToBase64(publicKeyBytes),
    nonce: bytesToBase64(randomBytes(16)),
    createdAt: nowIso
  };
  const requestBytes = textEncoder.encode(JSON.stringify(requestPayload));
  const requestBase64 = bytesToBase64(requestBytes);

  let createResponse;
  try {
    createResponse = await api.mls.requestCredential({
      clientId: clientIdBase64,
      ciphersuite: DEFAULT_CIPHERSUITE,
      request: requestBase64
    });
  } catch (error) {
    if (error instanceof ApiError && error.status === 404) {
      console.warn('[MLS] Credential provisioning endpoint not available (404).');
      return cached;
    }
    throw error;
  }

  const rawRequestId = createResponse?.id ?? null;
  const numericRequestId = Number(rawRequestId);
  const requestId = Number.isInteger(numericRequestId) ? numericRequestId : rawRequestId;
  const credentialB64 = createResponse?.credential;
  if (!credentialB64) {
    throw new Error('MLS credential provisioning failed: missing credential payload');
  }

  try {
    await api.mls.completeCredential({
      requestId,
      response: credentialB64
    });
  } catch (error) {
    writeStoredCredential(null);
    throw error;
  }

  const credentialPayload = parseCredentialResponse(credentialB64) || {};
  const credentialInfo = credentialPayload?.credential || {};
  const stored = {
    requestId: Number.isInteger(numericRequestId) ? numericRequestId : rawRequestId,
    credential: credentialB64,
    issuedAt: credentialInfo.issuedAt ?? createResponse?.issuedAt ?? null,
    expiresAt: credentialInfo.expiresAt ?? createResponse?.expiresAt ?? null,
    signer: credentialPayload?.signer ?? createResponse?.signer ?? null,
    requestHash: createResponse?.requestHash ?? credentialPayload?.requestHash ?? null
  };

  writeStoredCredential(stored);
  return stored;
};

export const ensureMlsBootstrap = async () => {
  if (!FEATURE_FLAG) return null;
  if (bootstrapPromise) return bootstrapPromise;
  bootstrapPromise = (async () => {
    const coreCrypto = await getCoreCrypto();
    if (!coreCrypto) return null;

    const tokenData = getTokenData?.();
    const userId = Number(tokenData?.userId ?? null);
    if (!Number.isInteger(userId)) {
      throw new Error('MLS bootstrap requires an authenticated user');
    }

    const clientIdBytes = getOrCreateClientId();
    const clientIdB64 = bytesToBase64(clientIdBytes);
    const credentialInfo = await ensureCredentialProvisioned(coreCrypto, {
      userId,
      clientIdBytes,
      clientIdBase64: clientIdB64
    }).catch((error) => {
      console.warn('[MLS] Credential provisioning failed', error);
      throw error;
    });
    if (credentialInfo) {
      cachedCredentialInfo = credentialInfo;
    }

    const shouldPublish = !shouldSkipKeyPackageUpload();
    const result = await coreCrypto.transaction(async (ctx) => {
      // Touch the client's public key so that a basic credential exists.
      await ctx.clientPublicKey(DEFAULT_CIPHERSUITE, CredentialType.Basic);

      const currentCountBigInt = await ctx.clientValidKeypackagesCount(DEFAULT_CIPHERSUITE, CredentialType.Basic);
      const currentCount = Number(currentCountBigInt ?? 0);
      const target = Math.max(DEFAULT_KEYPACKAGE_TARGET, 1);
      if (currentCount >= target && !shouldPublish) {
        return { generated: [] };
      }

      const amountRequested = Math.max(target - currentCount, shouldPublish ? target : 0);
      if (amountRequested <= 0) {
        return { generated: [] };
      }

      const generated = await ctx.clientKeypackages(DEFAULT_CIPHERSUITE, CredentialType.Basic, amountRequested);
      return { generated };
    });

    const generated = result?.generated || [];
    if (generated.length && shouldPublish) {
      const payload = generated.map(bytesToBase64);
      try {
        await api.mls.publishKeyPackages({
          clientId: clientIdB64,
          ciphersuite: DEFAULT_CIPHERSUITE,
          credentialType: 'basic',
          keyPackages: payload
        });
        markKeyPackagesUploaded();
      } catch (error) {
        if (error instanceof ApiError && error.status === 404) {
          // Backend not ready yet; surface as a warning but don't fail the bootstrap.
          if (import.meta?.env?.DEV) {
            console.warn('[MLS] Key package publish endpoint missing (404).', error);
          }
        } else {
          console.warn('[MLS] Failed to publish key packages:', error?.message || error);
          throw error;
        }
      }
    }
    return null;
  })().catch((err) => {
    bootstrapPromise = null;
    throw err;
  });
  return bootstrapPromise;
};

export const getClientIdBase64 = () => bytesToBase64(getOrCreateClientId());

export const getCachedCredentialInfo = () => {
  if (cachedCredentialInfo) return cachedCredentialInfo;
  const stored = readStoredCredential();
  cachedCredentialInfo = stored;
  return stored;
};

const encodeConversationId = (conversationId) => {
  if (conversationId instanceof Uint8Array) return conversationId;
  return textEncoder.encode(String(conversationId));
};

export const createConversationId = (conversationId) => new ConversationId(encodeConversationId(conversationId));

export const base64ToUint8 = (value) => base64ToBytes(value);
export const uint8ToBase64 = (bytes) => bytesToBase64(bytes);
export let DEFAULT_MLS_CIPHERSUITE = DEFAULT_CIPHERSUITE;
